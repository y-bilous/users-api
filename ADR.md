# Architecture decision record


## При реалізації було розглянуто наступні рішення:

## 1. Формат відповіді
- **Рішення:** Використовувати стандартний **JSON API формат**.
- **Причина:** Це забезпечує передбачуваність та легшу інтеграцію.
- **Приклад відповіді:**
```json
{
  "data": {
    "id": 1,
    "login": "user123",
    "phone": "+380991234567"
  }
}
```
- **Статус:** Прийнято



## 2. Обмеження довжини атрибутів
- **Рішення:** 
- **Login:** до 32 символів.
- **Phone:** до 15 символів.
- **Password:** мінімум 8 символів, без верхньої межі.
- **Причина:** 8 символів — занадто мало для реальних даних і небезпечно для паролів.
- **Статус:** Прийнято



## 3. Тип для `id`
- **Рішення:** Використовувати `int AUTO_INCREMENT`, але best practice для API — UUID.
- **Альтернатива:** Використовувати **UUID v4** як первинний ключ.
- **Причина:** UUID краще підходить для розподілених систем і безпечніше ніж автоінкремент int, проте для простої системи візьмемо AUTO_INCREMENT.
- **Статус:** Прийнято


## 4. Bearer токени: expiry та refresh
- **Рішення:**
  - Access токен має **expiry** (наприклад, 60 хвилин).
  - Refresh токен — довший (наприклад, 7 днів).
- **Причина:** Це стандартна практика безпеки (OAuth2/JWT).
- **Symfony:** Використовуємо `lexik/jwt-authentication-bundle`.
- **Статус:** Прийнято


## 5. Механізм отримання токена
- **Рішення:**
  - Користувач отримує токен через **login/password** запит на `/api/login`.
  - У відповідь повертається `access_token`.
  - Для простоти будемо використовувати `json login`
- **Причина:** Це стандартна схема для REST API з JWT.
- **Статус:** Прийнято


## 6. Права root
- **Рішення:** 
  - Root може створювати, редагувати та видаляти **будь-яких користувачів**.
  - User може працювати лише зі **своїм користувачем** (id з токена). Не може видаляти та створювати користувачів.
  - **Статус:** Прийнято


## 7. Документація API
- **Рішення:** Використати **OpenAPI/Swagger** (через `nelmio/api-doc-bundle`).
- **Причина:** Це стандарт для документування REST API, полегшує інтеграцію та тестування.
- **Статус:** Прийнято


## 8. Пагінація для GET
- **Рішення:**  При отриманні списку користувачів `GET /v1/api/users` — додати пагінацію (`?page=1&limit=20`).
- **Причина:** Масштабованість і оптимізація запитів.
- **Symfony:** Використати `Pagerfanta` для готової пагінації.
- **Статус:** Не прийнято. (Для простого проєкту не є обов'язковим)


## 9. Налаштування проєкту
- **Рішення:** 
  - Використати Docker — спрощує розгортання проєкту та локальну розробку.
  - Використати SQLite — підходить для тестового завдання. Проста база даних, відповідає вимогам задачі.
- **Статус:** Прийнято


## 10. Розвиток проєкту (maintainability, testability)
- **Рішення:** 
  - Використати тактичні шаблони DDD: `DTO, Value Object, Repository, Service` і т.п. Шаблони задають коду чітку структуру та допомогають моделювати складну бізнес логіку, проте створюють додаткові абстракції, що підвищує складність проєкту.
  - Покрити проєкт тестами — тести роблять код більш надійним, проте займають час на написання й підтримку.
- **Статус:** Не прийнято (Для простого проєкту не є обов'язковим)
